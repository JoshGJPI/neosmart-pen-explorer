/* 
 * This is a simplified version of the WebPenSDK for browser compatibility
 * Based on the SDK found in the WEB-SDK2.0 repository
 */

// PenMessageType constants
const PenMessageType = {
  PEN_AUTHORIZED: 1,
  PEN_PASSWORD_REQUEST: 2,
  PEN_DISCONNECTED: 4,
  PEN_CONNECTION_SUCCESS: 6,
  PEN_SETTING_INFO: 17,
  PEN_SETUP_SUCCESS: 18,
  PEN_USING_NOTE_SET_RESULT: 26,
  PASSWORD_SETUP_SUCCESS: 82,
  EVENT_LOW_BATTERY: 99,
  EVENT_POWER_OFF: 100,
  PEN_FW_UPGRADE_STATUS: 34,
  EVENT_DOT_PUI: 105,
  OFFLINE_DATA_NOTE_LIST: 48,
  OFFLINE_DATA_PAGE_LIST: 49,
  OFFLINE_DATA_SEND_START: 50,
  OFFLINE_DATA_SEND_STATUS: 51,
  OFFLINE_DATA_SEND_SUCCESS: 52,
  OFFLINE_DATA_SEND_FAILURE: 53
};

// PenHelper class
class PenHelper {
  constructor() {
    this.pens = [];
    this.dotCallback = null;
    this.messageCallback = null;
    this.isDebugMode = false;
  }

  debugMode(enabled) {
    this.isDebugMode = enabled;
    console.log("Debug mode:", enabled);
  }

  logDebug(message, ...args) {
    if (this.isDebugMode) {
      console.log(message, ...args);
    }
  }

  // Connect to a pen via Bluetooth
  async scanPen() {
    try {
      if (!navigator.bluetooth) {
        throw new Error("Web Bluetooth is not supported in this browser");
      }
      
      const isBluetoothAvailable = await navigator.bluetooth.getAvailability();
      if (!isBluetoothAvailable) {
        throw new Error("Bluetooth is not available on this device");
      }
      
      // Define the Bluetooth filter options
      const options = {
        filters: [
          { namePrefix: "Neo" },
          { services: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"] }
        ],
        optionalServices: ["battery_service"]
      };
      
      // Request the Bluetooth device
      const device = await navigator.bluetooth.requestDevice(options);
      
      if (!device) {
        throw new Error("No device selected");
      }
      
      this.logDebug("Selected device:", device.name, device.id);
      
      // Connect to the device
      await this.connectDevice(device);
      
      return true;
      
    } catch (error) {
      console.error("Error scanning for pen:", error);
      throw error;
    }
  }
  
  // Connect to the device
  async connectDevice(device) {
    try {
      this.logDebug("Connecting to GATT server...");
      const server = await device.gatt.connect();
      
      this.logDebug("Getting primary service...");
      let service;
      try {
        // Try to get the 128-bit UUID service
        service = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
      } catch (err) {
        // Fallback to 16-bit UUID
        service = await server.getPrimaryService(0x19F1);
      }
      
      this.logDebug("Getting characteristics...");
      let txCharacteristic, rxCharacteristic;
      
      try {
        // Try to get characteristics with 128-bit UUIDs
        rxCharacteristic = await service.getCharacteristic("6e400002-b5a3-f393-e0a9-e50e24dcca9e");
        txCharacteristic = await service.getCharacteristic("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
      } catch (err) {
        // Fallback to 16-bit UUIDs
        rxCharacteristic = await service.getCharacteristic(0x2BA0);
        txCharacteristic = await service.getCharacteristic(0x2BA1);
      }
      
      // Create a PenController
      const penController = new PenController();
      penController.device = device;
      
      // Set up notifications
      await txCharacteristic.startNotifications();
      txCharacteristic.addEventListener('characteristicvaluechanged', (event) => {
        const value = event.target.value;
        let data = [];
        for (let i = 0; i < value.byteLength; i++) {
          data.push(value.getUint8(i));
        }
        penController.putData(data);
      });
      
      // Add write capability
      penController.addWrite((data) => {
        rxCharacteristic.writeValue(new Uint8Array(data))
          .catch(err => {
            console.error("Error writing to characteristic:", err);
          });
      });
      
      // Set callbacks
      penController.addCallback(
        this.handleDot.bind(this, penController),
        this.handleMessage.bind(this, penController)
      );
      
      // Set up disconnection handler
      device.addEventListener('gattserverdisconnected', () => {
        this.handleDisconnection(penController);
      });
      
      // Add to list of connected pens
      this.pens.push(penController);
      
      // Initialize the pen
      penController.OnConnected();
      
      return penController;
      
    } catch (error) {
      console.error("Error connecting to device:", error);
      throw error;
    }
  }
  
  // Handle dot data from the pen
  handleDot(controller, dot) {
    if (this.dotCallback) {
      const mac = controller.info.MacAddress;
      this.dotCallback(mac, dot);
    }
  }
  
  // Handle messages from the pen
  handleMessage(controller, type, args) {
    if (this.messageCallback) {
      const mac = controller.info.MacAddress;
      this.messageCallback(mac, type, args);
    }
  }
  
  // Handle pen disconnection
  handleDisconnection(controller) {
    this.logDebug("Pen disconnected:", controller.info.MacAddress);
    
    // Remove from pens list
    this.pens = this.pens.filter(p => p !== controller);
    
    // Notify controller
    controller.OnDisconnected();
  }
  
  // Disconnect a pen
  disconnect(controller) {
    if (controller && controller.device && controller.device.gatt) {
      controller.device.gatt.disconnect();
    }
  }
  
  // Check if pages are the same
  isSamePage(page1, page2) {
    if (!page1 || !page2) return false;
    
    return (
      page1.section === page2.section &&
      page1.owner === page2.owner &&
      page1.book === page2.book &&
      page1.page === page2.page
    );
  }
  
  // Check if a page is a SmartPlate
  isPlatePaper(pageInfo) {
    return (pageInfo.owner === 1013 && pageInfo.book === 2);
  }
  
  // Convert ncode coordinates to screen coordinates
  ncodeToScreen(dot, view, paperSize) {
    // Simple conversion - in a real implementation this would be more sophisticated
    const widthRatio = view.width / (paperSize.Xmax - paperSize.Xmin);
    const heightRatio = view.height / (paperSize.Ymax - paperSize.Ymin);
    
    const x = (dot.x - paperSize.Xmin) * widthRatio;
    const y = (dot.y - paperSize.Ymin) * heightRatio;
    
    return { x, y };
  }
}

// PenController class
class PenController {
  constructor() {
    this.onDot = null;
    this.onMessage = null;
    this.handleWrite = null;
    this.info = {
      MacAddress: "",
      deviceName: ""
    };
    this.device = null;
    this.status = {
      Battery: 0,
      Storage: "Unknown"
    };
  }
  
  addCallback(handleDot, handleMessage) {
    this.onDot = handleDot;
    this.onMessage = handleMessage;
  }
  
  addWrite(handleWrite) {
    this.handleWrite = handleWrite;
  }
  
  putData(data) {
    // This would normally parse the binary data from the pen
    // For simplicity, we're just handling some basic message simulation
    
    // In a real implementation, this would decrypt and parse the pen's protocol
    // For now, we'll just forward dot data to handlers if this looks like a dot packet
    
    if (data.length > 0) {
      const packetType = data[0];
      
      // Simulate receiving different packet types based on first byte
      if (packetType === 0x01) {
        // Version info packet
        this.info.MacAddress = "00:11:22:33:44:55";
        this.info.deviceName = "Neo Smartpen";
        
        // Notify version info
        if (this.onMessage) {
          this.onMessage(PenMessageType.PEN_SETTING_INFO, {
            Battery: 85,
            Storage: "50%"
          });
        }
      }
    }
  }
  
  OnConnected() {
    // Send initial requests to the pen
    this.RequestVersionInfo();
  }
  
  OnDisconnected() {
    // Notify disconnection
    if (this.onMessage) {
      this.onMessage(PenMessageType.PEN_DISCONNECTED, null);
    }
  }
  
  // Request the pen's version info
  RequestVersionInfo() {
    if (this.handleWrite) {
      // In a real implementation, this would be a proper command packet
      this.handleWrite([0x01, 0x10, 0x00, 0x00, 0x00]);
    }
    
    return this.info;
  }
  
  // Input password to the pen
  InputPassword(password) {
    if (this.handleWrite) {
      // In a real implementation, this would be a proper command packet
      this.handleWrite([0x01, 0x30, password.charCodeAt(0), password.charCodeAt(1), 
                         password.charCodeAt(2), password.charCodeAt(3)]);
    }
    
    // Simulate successful authorization
    setTimeout(() => {
      if (this.onMessage) {
        this.onMessage(PenMessageType.PEN_AUTHORIZED, null);
      }
    }, 500);
  }
  
  // Request pen status
  RequestPenStatus() {
    if (this.handleWrite) {
      // In a real implementation, this would be a proper command packet
      this.handleWrite([0x01, 0x11, 0x00, 0x00, 0x00]);
    }
    
    // Simulate receiving pen status
    setTimeout(() => {
      if (this.onMessage) {
        this.onMessage(PenMessageType.PEN_SETTING_INFO, {
          Battery: 85,
          Storage: "50%"
        });
      }
    }, 500);
  }
  
  // Request list of offline notes
  RequestOfflineNoteList(section, owner) {
    if (this.handleWrite) {
      // In a real implementation, this would be a proper command packet
      this.handleWrite([0x01, 0x31, section, owner, 0x00]);
    }
    
    // Simulate receiving offline note list
    setTimeout(() => {
      if (this.onMessage) {
        const mockNoteList = [
          { Section: 1, Owner: 1, Note: 1 },
          { Section: 1, Owner: 1, Note: 2 }
        ];
        this.onMessage(PenMessageType.OFFLINE_DATA_NOTE_LIST, mockNoteList);
      }
    }, 1000);
  }
  
  // Request list of pages in a note
  RequestOfflinePageList(section, owner, note) {
    if (this.handleWrite) {
      // In a real implementation, this would be a proper command packet
      this.handleWrite([0x01, 0x32, section, owner, note]);
    }
    
    // Simulate receiving page list
    setTimeout(() => {
      if (this.onMessage) {
        const mockPageList = {
          Section: section,
          Owner: owner,
          Note: note,
          Pages: [1, 2, 3, 4, 5]
        };
        this.onMessage(PenMessageType.OFFLINE_DATA_PAGE_LIST, mockPageList);
      }
    }, 1000);
  }
  
  // Request offline data
  RequestOfflineData(section, owner, note, deleteOnFinished, pages) {
    if (this.handleWrite) {
      // In a real implementation, this would be a proper command packet
      const pagesArray = Array.isArray(pages) ? pages : [];
      this.handleWrite([0x01, 0x33, section, owner, note, deleteOnFinished ? 1 : 0, 
                         ...pagesArray]);
    }
    
    // Simulate receiving offline data
    setTimeout(() => {
      if (this.onMessage) {
        // Start
        this.onMessage(PenMessageType.OFFLINE_DATA_SEND_START, null);
        
        // Progress updates
        for (let progress = 10; progress <= 100; progress += 30) {
          setTimeout(() => {
            this.onMessage(PenMessageType.OFFLINE_DATA_SEND_STATUS, progress);
          }, progress * 20);
        }
        
        // Complete - send mock stroke data
        setTimeout(() => {
          const mockData = this.createMockStrokeData(section, owner, note, pages);
          this.onMessage(PenMessageType.OFFLINE_DATA_SEND_SUCCESS, mockData);
        }, 2500);
      }
    }, 500);
  }
  
  // Create mock stroke data for testing
  createMockStrokeData(section, owner, note, pages) {
    const strokes = [];
    const pageArray = pages.length > 0 ? pages : [1, 2, 3, 4, 5];
    
    pageArray.forEach(page => {
      // Create 2-5 strokes per page
      const strokeCount = 2 + Math.floor(Math.random() * 4);
      
      for (let s = 0; s < strokeCount; s++) {
        const dots = [];
        
        // Start point (PEN_DOWN)
        const startX = 100 + Math.random() * 300;
        const startY = 100 + Math.random() * 200;
        
        dots.push({
          pageInfo: { section, owner, book: note, page },
          x: startX,
          y: startY,
          f: 500 + Math.random() * 400,
          dotType: 0, // PEN_DOWN
          timeStamp: Date.now() - 60000 + s * 1000 // Timestamps starting from a minute ago
        });
        
        // Move points (PEN_MOVE)
        const pointCount = 10 + Math.floor(Math.random() * 20);
        let lastX = startX;
        let lastY = startY;
        
        for (let p = 0; p < pointCount; p++) {
          const deltaX = (Math.random() - 0.5) * 30;
          const deltaY = (Math.random() - 0.5) * 30;
          
          lastX += deltaX;
          lastY += deltaY;
          
          dots.push({
            pageInfo: { section, owner, book: note, page },
            x: lastX,
            y: lastY,
            f: 500 + Math.random() * 400,
            dotType: 1, // PEN_MOVE
            timeStamp: dots[dots.length - 1].timeStamp + 50 + Math.random() * 20
          });
        }
        
        // End point (PEN_UP)
        dots.push({
          pageInfo: { section, owner, book: note, page },
          x: lastX,
          y: lastY,
          f: 100 + Math.random() * 200,
          dotType: 2, // PEN_UP
          timeStamp: dots[dots.length - 1].timeStamp + 50
        });
        
        strokes.push({ Dots: dots });
      }
    });
    
    return strokes;
  }
}

// Export the classes
try {
  // CommonJS environment (Node.js)
  if (typeof exports !== 'undefined') {
    exports.PenHelper = new PenHelper();
    exports.PenMessageType = PenMessageType;
    exports.PenController = PenController;
  }
  // Browser environment
  if (typeof window !== 'undefined') {
    // Make sure WebPenSDK object exists
    window.WebPenSDK = window.WebPenSDK || {};
    
    // Add exports to WebPenSDK
    window.WebPenSDK.PenHelper = new PenHelper();
    window.WebPenSDK.PenMessageType = PenMessageType;
    window.WebPenSDK.PenController = PenController;
  }
} catch (e) {
  console.error('Error exporting SDK classes:', e);
}
